( defun make-deck () 
  (let (
        ( ranks '(2 3 4 5 6 7 8 9 10 jack queen king ace) )
        ( suits '(club diamond heart spade) )
        )
    (mapcan (lambda (x) (mapcar 'cons ranks (duplicate (length ranks ) x)) ) suits)
    )
  )

 (defun shuffle-deck () 
   ( setf *deck* ( shuffle ( make-deck ) ) )
   )
 ( defun shuffle ( deck )
   (random-permutation deck) ; the same logic.
   )
( defun demo--shuffle-deck ()
  ( format t ">>> Testing: shuffle-deck~%" )
  ( shuffle-deck )
  ( format t "--- *deck* = ~A~%" *deck* )
  ( format t "--- number of cards in *deck* = ~A~%" ( length *deck* ) )
  nil
  )

( defun deal-hands () 
  ( shuffle-deck )
  ( setf *hand1* () ) 
  ( setf *hand2* () ) 
  ( deal-card-to-hand1 )
  ( deal-card-to-hand2 )
  ( deal-card-to-hand1 )
  ( deal-card-to-hand2 )
  ( deal-card-to-hand1 )
  ( deal-card-to-hand2 )
  nil
  )

( defun deal-card-to-hand1 ()
  (let ()
    (setf *hand1* (snoc (car *deck*) *hand1*) )
    (setf *deck* (cdr *deck*) )
    )
  )

( defun deal-card-to-hand2 ()
  (let ()
    (setf *hand2* (snoc (car *deck*) *hand2*) )
    (setf *deck* (cdr *deck*) )
    )
  )
( defun demo--deal-hands ()
  ( format t ">>> Testing: deal-hands~%" )
  ( deal-hands )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( format t "--- number of cards in *deck* = ~A~%" ( length *deck* ) )
  nil
  )

( defun randomly-discard-cards ()
  ( randomly-discard-card-from-hand1 )
  ( randomly-discard-card-from-hand2 )
  nil
  )
( defun randomly-discard-card-from-hand1 ()
  ( setf (nth (random 3) *hand1*) nil)
  )
( defun randomly-discard-card-from-hand2 ()
  ( setf (nth (random 3) *hand2*) nil)
  )
( defun demo--randomly-discard-cards ()
  ( format t ">>> Testing: randomly-discard-cards~%")
  ( deal-hands )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( randomly-discard-cards )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  nil
  )

( defun replace-cards ()
  ( replace-card-in-hand1 )
  ( replace-card-in-hand2 )
  nil
  )
( defun replace-card-in-hand1 () 
  ( setf ( nth (position nil *hand1* ) *hand1*) (car *deck*))
  ( setf *deck* (cdr *deck* ) )
  )
( defun replace-card-in-hand2 () 
  ( setf ( nth (position nil *hand2* ) *hand2*) (car *deck*))
  ( setf *deck* (cdr *deck* ) )
  )
( defun demo--replace-cards ()
  ( format t ">>> Testing: replace-cards~%" )
  ( deal-hands )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( randomly-discard-cards )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( replace-cards )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  nil
  )

( defun players-each-take-a-turn ()
  ;( randomly-discard-cards )
  ( random-heuristically-discard-cards ) ; part 8
  ( replace-cards )
  nil
  )

( defun demo--players-each-take-a-turn ()
  ( format t ">>> Testing: players-each-take-a-turn~%" )
  ( deal-hands )
  ( format t "--- The hands ...~%")
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( players-each-take-a-turn )
  ( format t "--- Each player takes a turn ...~%")
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( players-each-take-a-turn )
  ( format t "--- Each player takes a turn ...~%")
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( players-each-take-a-turn )
  ( format t "--- Each player takes a turn ...~%")
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( players-each-take-a-turn )
  ( format t "--- Each player takes a turn ...~%")
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  nil
  )

( defun flush-p (hand)
    ((lambda (x) (null (remove (car x) x))) (mapcar 'cdr hand))
    )

( defun demo--flush-p ( &aux hand )
  ( format t ">>> Testing: flush-p~%" )
  ( setf hand '( ( 2 . club ) ( ace . club ) ( 10 . club) ) )
  ( format t "~A " hand )
  ( if ( flush-p hand )
      ( format t "is a flush~%" )
      ( format t "is not a flush~%")
  )
  ( setf hand '( ( jack . diamond ) ( 9 . diamond ) ( 5 . diamond ) ) )
  ( format t "~A " hand )
  ( if ( flush-p hand )
      ( format t "is a flush~%")
      ( format t "is not a flush~%")
  )
  ( setf hand '( ( jack . heart ) ( 10 . heart ) ( 9 . heart ) ) )
  ( format t "~A " hand )
  ( if ( flush-p hand )
      ( format t "is a flush~%")
      ( format t "is not a flush~%")
  )
  ( setf hand '( ( 2 . spade ) ( 3 . spade ) ( ace . spade ) ) )
  ( format t "~A " hand )
  ( if ( flush-p hand )
      ( format t "is a flush~%")
      ( format t "is not a flush~%")
  )
  ( setf hand '( ( 10 . spade ) ( 5 . diamond ) ( ace . spade ) ) )
  ( format t "~A " hand )
  ( if ( flush-p hand )
      ( format t "is a flush~%")
      ( format t "is not a flush~%")
  )
  ( setf hand '( ( 8 . club ) ( 9 . diamond ) ( 10 . heart ) ) )
  ( format t "~A " hand )
  ( if ( flush-p hand )
      ( format t "is a flush~%")
      ( format t "is not a flush~%")
  )
  nil
  )

( defun high-card (hand) 
  (car (sort-by-rank hand))
  )

( defun sort-by-rank (hand) 
  (sort (copy-list hand) 
             (lambda ( x y ) 
               (labels
                   ( 
                     (ranker (a)
                       (cond 
                         ((numberp (car a)) (car a))
                         ((equal (car a) 'ace) 14)
                         ((equal (car a) 'king) 13)
                         ((equal (car a) 'queen) 12)
                         ((equal (car a) 'jack) 11)
                         (t 0)
                         )
                       )
                     )
                 (> (ranker x) (ranker y))
                 )
               )
       )
  )

( defun demo--high-card ()
  ( format t ">>> Testing: high-card~%" )
  ( setf hand '( ( 10 . heart ) ( 5 . club ) ( queen . spade ) ( 7 . heart ) ) )
  ( format t "~A is the high card of ~%  ~A~%" ( high-card hand ) hand )
  ( setf hand '( ( 2 . diamond ) ( 2 . club ) ( 10 . heart ) ( 4 . diamond ) ( ace . club ) ) )
  ( format t "~A is the high card of ~%  ~A~%" ( high-card hand ) hand )
  ( setf hand '( ( ace . diamond ) ( ace . club ) ( 5 . spade ) ) )
  ( format t "~A is the high card of ~%  ~A~%" ( high-card hand ) hand )
  nil
  )

( defun straight-p (hand) 
  (let (
        ( sorted-hand (sort-by-rank hand ))
        ( order '(ace king queen jack 10 9 8 7 6 5 4 3 2 ) )
        )
    (not (member nil (mapcar (lambda (x y) (eq x (car y))) (member (car(car sorted-hand)) order) sorted-hand)))
    )
  )

( defun demo--straight-p ()
  ( format t ">> Testing straight-p~%" )
  ( setf hand '( ( 5 . spade ) ( 3 . diamond ) ( 4 . spade ) ( 6 . club ) ) )
  ( format t "~A " hand )
  ( if ( straight-p hand )
      ( format t "is a straight~%" hand)
      ( format t "is not a straight~%" hand)
  )
  ( setf hand '( ( 5 . spade ) ( 7 . diamond ) ( 4 . spade ) ( 8 . club ) ) )
  ( format t "~A " hand )
  ( if ( straight-p hand )
      ( format t "is a straight~%" hand)
      ( format t "is not a straight~%" hand)
  )
  ( setf hand '( ( king . heart ) ( queen . diamond ) ( ace . spade ) ( 10 . club ) ( jack . diamond ) ) )
  ( format t "~A " hand )
  ( if ( straight-p hand )
      ( format t "is a straight~%" hand)
      ( format t "is not a straight~%" hand)
  )
  ( setf hand '( ( ace . club ) ( 2 . diamond ) ( 3 . spade ) ) )
  ( format t "~A " hand )
  ( if ( straight-p hand )
      ( format t "is a straight~%" hand)
      ( format t "is not a straight~%" hand)
  )
  nil
  )

( defun analyze-hand (hand) 
  ( if 
      (flush-p hand)
      ( let* 
          (
           (highest (high-card hand))
           (highest-rank (car highest))
           (flush-suit (cdr highest))
           (straight (straight-p hand))
           )
        ( if 
            straight
            (list highest-rank 'high 'straight flush-suit 'flush)
            (list highest-rank 'high flush-suit 'flush)
            )
        )
      'bust
      )
  )

( defun demo--analyze-hand () 
  ( format t ">>> Testing: analyze-hand~%" )
  ( setf hand '( ( 5 . spade ) ( 3 . diamond ) ( 4 . spade ) ) )
  ( format t "~A is a ~A~%" hand ( analyze-hand hand ) )
  ( setf hand '( ( 5 . club ) ( 9 . club ) ( 4 . club ) ) )
  ( format t "~A is a ~A~%" hand ( analyze-hand hand ) )
  ( setf hand '( ( queen . heart ) ( ace . heart ) ( king . heart ) ) )
  ( format t "~A is a ~A~%" hand ( analyze-hand hand ) )
  nil
  )

( defun analyze-game () 
  ( setf *game-state* ( list (analyze-hand *hand1*) (analyze-hand *hand2*) ) )
  )

( defun card-greater (c1 c2) 
  (if
      (equal (sort-by-rank ( list c1 c2 )) (list c1 c2) )
      t
      nil
      )
  )

( defun demo--analyze-game () 
  ( format t ">>> Testing: analyze-game~%" ) 
  ; a couple of busts
  ( format t "Game 1 ... ~%" )
  ( setf *hand1* '( ( 2 . diamond ) ( 4 . diamond ) ( jack . heart ) ) )
  ( setf *hand2* '( ( 10 . spade ) ( king . heart ) ( queen . heart ) ) )
  ( analyze-game )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( format t "*game-state* = ~A~%" *game-state* )
  ; an ordinary flush and a straight flush
  ( format t "Game 2 ... ~%" )
  ( setf *hand1* '( ( 10 . diamond ) ( jack . diamond ) ( 2 . diamond ) ) )
  ( setf *hand2* '( ( 3 . spade ) ( 5 . spade ) ( 4 . spade ) ) )
  ( analyze-game )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( format t "*game-state* = ~A~%" *game-state* )
  nil
  )

( defun report-the-result () 
  ( cond 
    ( ( equal *game-state* '( bust bust ) ) 
     ( increment '*draw-count* )
      ( format t "--> The game is a draw. The deck is dead.~%")
     )
    ( ( and ( not ( equal ( first *game-state* ) 'bust ) )
            ( equal ( second *game-state* ) 'bust ) 
            )
     ( increment '*win1-count* )
     ( format t "--> Player 1 wins with a ~A~%" ( first *game-state* ) )
     )
    ( ( and ( equal ( first *game-state* ) 'bust ) 
            ( not ( equal ( second *game-state* ) 'bust ) )
            )
     ( increment '*win2-count* )
     ( format t "--> Player 2 wins with a ~A~%" ( second *game-state* ) )
     )
    (
     ( and ( straight-p *hand1* ) ( not ( straight-p *hand2* ) ) )
     ( increment '*f1f2-count* )
     ( increment '*win1-count* )
     ( format t "!!! Both players found their way to a flush~%" )
     ( format t "--> Player 1 wins with a ~A~%" ( first *game-state* ) )
     )
    (
     ( and ( not ( straight-p *hand1* ) ) ( straight-p *hand2* ) )
     ( increment '*f1f2-count* )
     ( increment '*win2-count* )
     ( format t "!!! Both players found their way to a flush~%" )
     ( format t "--> Player 2 wins with a ~A~%" ( second *game-state* ) )
     )
    (
     ( card-greater ( high-card *hand1* ) ( high-card *hand2* ) )
     ( increment '*f1f2-count* )
     ( increment '*win1-count* )
     ( format t "!!! Both players found their way to a flush~%" )
     ( format t "--> Player 1 wins with a ~A~%" ( first *game-state* ) )
     )
    (
     ( card-greater ( high-card *hand2* ) ( high-card *hand1* ) )
     ( increment '*f1f2-count* )
     ( increment '*win2-count* )
     ( format t "!!! Both players found their way to a flush~%" )
     ( format t "--> Player 2 wins with a ~A~%" ( second *game-state* ) )
     )
    )
  nil
  )

( defun demo--report-the-result ()
  ( format t ">>> Testing: report-the-result~%" )
  ( setf *hand1* '( ( 2 . club ) ( 3 . spade ) ( 4 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . club ) ( 4 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  ( setf *hand1* '( ( 2 . club ) ( 3 . club ) ( 5 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . heart ) ( 4 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  ( setf *hand1* '( ( 2 . club ) ( 3 . heart) ( 4 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . spade ) ( 5 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  ( setf *hand1* '( ( 2 . club ) ( 3 . club ) ( 4 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . spade ) ( 6 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  ( setf *hand1* '( ( 2 . club ) ( 3 . club ) ( 5 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . spade ) ( 4 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  ( setf *hand1* '( ( 2 . club ) ( 3 . club ) ( 6 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . spade ) ( 5 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  ( setf *hand1* '( ( 2 . club ) ( 3 . club ) ( 5 . club ) ) )
  ( setf *hand2* '( ( 2 . spade ) ( 3 . spade ) ( 6 . spade ) ) )
  ( format t "*hand1*  = ~A~%" ( write-to-string *hand1* ) )
  ( format t "*hand2*  = ~A~%" *hand2* )
  ( analyze-game )
  ( report-the-result )
  )

( defun hand-rep (hand) 
  (labels 
      (
      ( rank-map (hand) 
        (mapcar (lambda (x) (cond
                  ((equal  ( car x ) 'ace) (cons 'A (cdr x)))
                  ((equal  ( car x ) 'king) (cons 'K (cdr x)))
                  ((equal  ( car x ) 'queen) (cons 'Q (cdr x)))
                  ((equal  ( car x ) 'jack) (cons 'J (cdr x)))
                  ((equal  ( car x ) '10) (cons 'X (cdr x)))
                  (t  x )
                  ))
                hand)
        )
      ( suit-map (hand) 
        (mapcar (lambda (x) (cond
                  ((equal  ( cdr x ) 'diamond) (cons (car x)'D ))
                  ((equal  ( cdr x ) 'spade) (cons (car x)'S ))
                  ((equal  ( cdr x ) 'club) (cons (car x)'C ))
                  ((equal  ( cdr x ) 'heart) (cons (car x)'H ))
                  ))
                hand)
        )
       )
    (suit-map ( rank-map hand ) ) 
  )
  )

( defun demo--hand-rep ( &aux hand )
  ( shuffle-deck )
  ( setf internal ( list ( pop *deck* ) ( pop *deck* ) ( pop *deck* ) ) )
  ( setf external ( hand-rep internal ) )
  ( format t "~A --> ~A~%" internal external )
  nil
  )

( defun play-game () 
  ( increment '*game-count* )
  ( deal-hands )
  ( make-moves )
  ( report-the-result )
  )

( defun make-moves () 
  ( increment '*turn-count* )
  ( format t "~A        ~A~%" ( hand-rep *hand1* ) ( hand-rep *hand2* ) )
  ( if ( not ( game-over-p ) )
      ( let ()
        ( players-each-take-a-turn )
        ( make-moves )
        )
      )
  nil
  )

( defun game-over-p () 
  ( analyze-game )
  ( or
      ( not ( equal *game-state* '( bust bust ) ) )
      ( null *deck* )
    )
  )

( defun demo--play-game ()
  ( format t ">>> Testing: play-game~%" )
  ( play-game )
  )

( defun init-counters () 
  ( setf *win1-count* 0 )
  ( setf *win2-count* 0 )
  ( setf *draw-count* 0 )
  ( setf *turn-count* 0 )
  ( setf *f1f2-count* 0 )
  ( setf *game-count* 0 )
  nil
  )

( init-counters )

; Flexibel counter incrementation
( defun increment (name)
  ( set name ( + ( eval name ) 1 ) ) 
  nil
  )
; The main statistics computation program
( defun compute-statistics ( n ) 
  ( init-counters )
  ( play-game-n-times n )
  ( format t "*game-count* = ~A~%" *game-count* )
  ( format t "*turn-count* = ~A~%" *turn-count* )
  ( format t "*win1-count* = ~A~%" *win1-count* )
  ( format t "*win2-count* = ~A~%" *win2-count* )
  ( format t "*draw-count* = ~A~%" *draw-count* )
  ( format t "*f1f2-count* = ~A~%" *f1f2-count* )
  )

; Program to play the game n times
( defun play-game-n-times ( n ) 
  ( cond 
    ( ( > n 0 ) 
     ( play-game )
     ( play-game-n-times ( - n 1 ) ) 
     )
    )
  )

( defun randomly-heuristically-discard-cards () 
  ( randomly-discard-card-from-hand1 )
  ( heuristic-discard-card-from-hand2 )
  nil
  )

( defun heuristic-discard-card-from-hand2 () 
  (let*
      (
      ;(suits (remove-duplicates (mapcar 'cdr (copy-list *hand2* ) ) :test 'equal ) )
      ( sorted-hand (sort-by-rank *hand2* ) )
      ( in-hand-suits ( mapcar 'cdr ( copy-list *hand2* ) ) )
      ( suits '(club diamond spade heart) )
      ( best-suits (sort suits (lambda (x y) (> (count x in-hand-suits) (count y in-hand-suits)))))
      ( suit-and-count (remove-if (lambda (x) (= 0 (cadr x) ) ) (mapcar (lambda (x) (list x ( count x in-hand-suits) ) ) best-suits) ))
      ( counts-are-not-equal (> (second (first suit-and-count)) (second (first (last suit-and-count)))  ))
    )
    ;(list counts-are-not-equal suit-and-count)
    (if counts-are-not-equal; if there is a suit with a lowest count in hand
        (let* ; remove the lowest card of that suit
          (
            (worst-suit (first (first ( last suit-and-count) ) ))
            (worst-card (first (last (remove-if-not (lambda (x) ( eq ( cdr x ) worst-suit ) ) (copy-list *hand2*) ) ) ) )
          )
          (setf (nth (position worst-card *hand2*) *hand2*) nil)
         )
      ; otherwise, discard the lowest valued card.
      (setf (nth (position (first (last sorted-hand)) *hand2*) *hand2*) nil)
        )
  )
  )

( defun demo--randomly-heuristically-discard-cards ()
  ( format t ">>> Testing: randomly-heuristically-discard-cards~%")
  ( deal-hands )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  ( randomly-heuristically-discard-cards )
  ( format t "--- *hand1* = ~A~%" *hand1* )
  ( format t "--- *hand2* = ~A~%" *hand2* )
  nil
  )
